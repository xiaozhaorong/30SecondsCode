{"./":{"url":"./","title":"前言","keywords":"","body":"30SecondsCode 30秒代码 不定时整理一下平时记录在有道云用到的东西 方便下次使用 gitPages 线上浏览 https://xiaozhaorong.github.io/30SecondsCode/index.html 安装淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装gitbook cnpm install gitbook -g 初始化书籍 gitbook init 本地预览书籍 gitbook serve 本地预览 http://localhost:4000 编译书籍 gitbook build . docs 安装gitBook 插件 gitbook install xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:36:24 "},"JavaScript/":{"url":"JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 16:44:01 "},"JavaScript/01字符串常用操作.html":{"url":"JavaScript/01字符串常用操作.html","title":"01字符串常用操作","keywords":"","body":"01常用的字符串转换 金额加￥ // -100 转换 -￥100 function formatMoney(money) { return money 字符串文字过长 截取换成... // 字符串文字过长 截取换成... function formatStr(str){ return str.length > 8 ? (str.substr(0,8) + '.'.repeat(3)) : str } formatStr('123456789') // 12345678... xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:20:09 "},"JavaScript/02正则常用操作.html":{"url":"JavaScript/02正则常用操作.html","title":"02正则常用操作","keywords":"","body":"正则 香不香 先看对比 不使用正则 在字符串中过滤数字// 不使用正则的情况下 在字符串中选出数字 let str = 'da231sda11213xvc312sfq23' let nums = [...str].filter(s => !Number.isNaN(parseInt(s))).join('') // 输出 2311121331223 console.log(nums) 使用的正则表达式let str = 'da231sda11213xvc312sfq23' // 使用正则表达式 选出数字 let nums2 = str.match(/\\d/g).join('') // 输出 2311121331223 console.log(nums2) 怎么用 使用对象创建正则表达式 不需要写字面量 let str = 'das12312adad' let reg = new RegExp('a','g') // 会返回true console.log(reg.test(str)) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:29:15 "},"JavaScript/03数组常用操作.html":{"url":"JavaScript/03数组常用操作.html","title":"03数组常用操作","keywords":"","body":"基础Api let arr = [] // push 加入数组尾部 返回长度 arr.push('a') // pop 从数组尾部移除 arr.pop() // unshift 追加到数组头部 返回长度 arr.unshift('b') // shift 从数组头部移除 arr.shift() 数组操作中间位置的元素 fill 数组指定位置替换数据let arr = [1,2,3,4].fill('空指针',1,4) // 运行结果 [1, \"空指针\", \"空指针\", \"空指针\"] console.log(arr) slice 截取指定位置的数组 返回新数组 不会改变原数组let arr = ['a','b','c','d'] // 运行结果 [\"b\", \"c\"] console.log(arr.slice(1,3)) splice 指定开始位置与需要截取几个元素 删除元素 会改变原数组let arr = ['a','b','c','d'] let tmp = arr.splice(1,1) // 运行结果已删除 [\"b\"] 原的数组 [\"a\", \"c\", \"d\"] console.log(tmp,arr) splice 指定定开始位置与需要截取几个元素 替换元素 会改变原数组let arr = [1,2,3,4] let tmp = arr.splice(1,2,'a') // 运行结果 [2, 3] [1, \"a\", 4] console.log(tmp,arr) splice 指定某个位置开始 增加元素let arr = [1,2,3,4] let tmp = arr.splice(2,0,'a') // 运行结果[] [1, 2, \"a\", 3, 4] console.log(tmp,arr) split 字符串拆分数组let tmp = 'a,b,c,d'.split(',') // 运行结果 [\"a\", \"b\", \"c\", \"d\"] console.log(tmp) join 按指定格式 将字符串合并成数组let str = ['a','b','c'].join('-') // 运行结果 \"a-b-c\" console.log(str) ... 两个数组合并 小栗子1let arr1 = ['a','b'] let arr2 = ['c','d'] let arr3 = [...arr1,...arr2] push 两个数组合并 小栗子2let arr1 = ['a','b'] let arr2 = ['c','d'] arr1.push(...arr2) concat 两个数组合并 小栗子3 let arr1 = ['a','b'] let arr2 = ['c','d'] arr1 = arr1.concat(arr2) copyWithin 将数组元素移动到指定位置 参数1 复制到指定元素的位置 参数2 要复制元素的开始位置 参数 要复制元素的结束位置 let arr = ['a','b','c','d','e'] console.log(arr.copyWithin(3,1,3)) 数组查找 indexOf 从左侧开始查找'c' 返回元素下标 let arr = ['a','b','c','d','e'] // 运行结果 c console.log(arr.indexOf('c')) includes 查找数组中是否包含元素 返回true || false let arr = ['a','b','c','d','e'] // 运行结果 true console.log(arr.includes('c')) find 查找对象 let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.find((item)=>{ return item.name === '小白' }) // 运行结果 { name: \"小白\", age: 18 } console.log(res) findIndex 返回元素下标let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.findIndex((item)=>{ return item.name === '小白' }) // 运行结果 0 console.log(res) 遍历对象数组拼接返回想要的元素let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.map((v) => v.name) // 运行结果 [\"小白\", \"小黑\"] console.log(res) 排序 sort 按价格从小到大排序let order = [ {name:'iphone',price:8000}, {name:'小米',price:5000}, {name:'华为',price:6000} ] order = order.sort((a,b)=>{ // b在前a在后从大到小排,a前b在后从小到大排 return a.price - b.price }) console.table(order) 循环 of 会返回值let arr = ['a','b','c'] // of 返回值 底层是用迭代器 iterator for(let v of arr){ console.log(v) } // 运行结果 > \"a\" > \"b\" > \"c\" in返回索引let arr = ['a','b','c'] for(let v in arr){ console.log(v) } // 运行结果 > \"0\" > \"1\" > \"2\" forEach item返回元素 index 返回下标let arr = ['a','b','c'] arr.forEach((item,index) => { console.log(index,item) }) // 运行结果 > 0 \"a\" > 1 \"b\" > 2 \"c\" iterator 迭代器 arr.values() 返回一个值迭代器对象let arr = ['a','b','c'] let values = arr.values() while(({value,done} = values.next() )&& done === false){ console.log(value) } // 运行结果 > \"a\" > \"b\" > \"c\" iterator 迭代器 arr.keys() 返回一个下标迭代器对象let arr = ['a','b','c'] let keys = arr.keys() while(({value,done} = keys.next() )&& done === false){ console.log(value) } // 运行结果 > 0 > 1 > 2 判断 every 用于判断数组元素是否全部符合条件let user = [{name:'a',js:99},{name:'b',js:66},{name:'c',js:89}] // every 用于判断数组元素是否全部符合条件 let res = user.every(function(item) { return item.js >= 60 }) // 运行结果 true console.log(res) some 数组中一个值为真 则返回真let user = [{name:'a',js:99},{name:'b',js:66},{name:'c',js:89}] // some 用于判断数组元素是否全部符合条件 let res = user.some((item)=>{ return item.js >= 60 }) // 运行结果 true console.log(res) filter 过滤 查询不等于'b'的数据let arr = ['a','b','b','d'] let newArr = arr.filter((item)=>{ return item != 'b' }) // 运行结果 [\"a\", \"d\"] console.log(newArr) 自己实现filterfunction filter(array,callback){ let newArray = [] for(const v of array){ if(callback(v) === true){ newArray.push(v) } } return newArray } let arr = ['a','b','c','a','d','a'] let tmp = filter(arr,(item)=>{return item != 'a'}) // 运行结果 [\"b\", \"c\", \"d\"] console.log(tmp) reduce 小栗子1 统计a字符出现的次数let arr = ['a','b','c','a','a'] // 使用reduce 统计某字符出现的字数 let res = arr.reduce((total,cur)=>{ total += 'a' === cur ? 1:0 return total },0) // 运行结果 3 console.log(res) reuce 小栗子2 计算订单总数let order = [ {name:'iphone',price:8000}, {name:'小米',price:5000}, {name:'华为',price:6000} ] // 计算订单总数 let sum = order.reduce(((total,cur)=>{ return (total += cur['price']) }),0) // 运行结果 19000 console.log(sum) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:32:11 "},"JavaScript/04Date常用操作.html":{"url":"JavaScript/04Date常用操作.html","title":"04Date常用操作","keywords":"","body":" 获取两个日期相差的天数 //参数格式 2020-11-11 获取两个日期相差的天数 differDay(start, end) { console.log(start, end) return (Date.parse(start) - Date.parse(end)) / (24 * 3600 * 1000) }, xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:48:55 "},"JavaScript/05ES6新增对象.html":{"url":"JavaScript/05ES6新增对象.html","title":"05ES6新增对象","keywords":"","body":"Symbol 是什么 产生一个唯一的数据 为什么 特殊情况下 有两个一模一样的值 在不改变其值的情况下,使其独立存在 怎么用 声明n次 会出现n个不一样的let s = Symbol('一只空指针') //运行结果 一只空指针 console.log(s.description) 声明n次 只会出现一个一样的 for of / for in 不能遍历到Symbol里面的值 所以可以用来当私有属性 解除字符串耦合的问题 let user1 = { name: '小白1', key: Symbol() } let user2 = { name: '小白1', key: Symbol() } let grade = { [user1.key]: {js:100,css:99}, [user2.key]: {js:20,css:29} } console.log(grade[user1.key]) Set类型 是什么 ES6 新增的数据结构 与数组类型，但是当元素为值类型时 会自动去重 怎么用let s = new Set() s.add(1) s.add(1) // 运行结果 输出1 console.log(s) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:48:46 "},"JavaScript/06函数常用操作.html":{"url":"JavaScript/06函数常用操作.html","title":"06函数常用操作","keywords":"","body":"函数 函数给默认值 数组排序小栗子function sortArray(array,type='asc'){ return array.sort((a,b)=>{ return type === 'asc' ? a-b:b-a; }) } arr = [1,23,32,1,32,43,6] console.log(sortArray(arr)) arguments 参数数量不确定 在函数内部获取到参数function sum(){ return [...arguments].reduce((a,b)=>a+b) } console.log(sum(1,2,3,4,5)) 相同解决方案 用...语法function sum(...args){ return args.reduce((a,b)=>a+b) } console.log(sum(1,2,3,4,5)) 箭头函数简写 筛选数组let arr = [1,23,43,32,3,123,3,2,1,23,5].filter(value=>value 递个龟 写个n的阶乘吧function factorial(num){ return num === 1 ? 1 : num * factorial(--num) } console.log(factorial(5)) 再递个龟 写个数组求和 function sum(...args){ return args.length === 0 ? 0 : args.pop() + sum(...args) } console.log(sum(1,2,3,5)) this指向 name = '小黑' let edu = { name: '小白', show: function(){ //有对象引用 输出edu对象 console.log('外层',this.name) function render(){ //无对象引用 输出window对象 console.log('内层',this.name) } render() } } edu.show() 多层函数获取外部this指向 可以用 变量 self 暂存 let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ const self = this; return this.lists.map((v)=>{ console.log(self.site + v) }) } } Lesson.show() map函数可以 多传一个参数 将this传入 那么就不需要 第三方变量暂存了let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ return this.lists.map(function(v){ console.log(this.site + v) },this) } } Lesson.show() 箭头函数 会改变this指向所以可以直接获取到外部的this let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ return this.lists.map((v)=>{ console.log(this.site + v) }) } } Lesson.show() 闭包面试题 以下代码输出什么 var name = \"W\" var obj = { name:\"My Object\", getName: function(){ return function(){ return this.name } } } // return this.name 没有绑定对象 默认指向window 输出W console.log(obj.getName()()) // ------------------------------ var name = \"W2\" var obj = { name: \"W Obj\", getName: function(){ var that = this; return function(){ return that.name } } } // that保存了外部的this指向 输出\"W Obj\" console.log(obj.getName()()) call 改变this指向 立即执行 function User(name){this.name = name;} let lisi = new User('李四') console.log(lisi) let u = {age: 22} // 默认会调用构造函数 生成{}对象 往里面添加属性 call 会 将this指针指向传入对象 基于已有对象添加属性 User.call(u,\"测试\") console.log(u) apply 也是改变this指向 区别 不会立即执行 在构造函数有参数时 传参不同 let lisi = { name: '李四' } let ww = { name: '王五' } function User(age){ console.log(this.name + ':' + age) } User.call(lisi,22) // apply 传递的是数组 User.apply(ww,[11]) bind 改变this指向 不会立即执行 小栗子 动态改变show this里面的值 btn1 btn2 btn3 function show() { alert(this.innerHTML) } let btns = document.querySelectorAll('button') for (let i = 0; i { show.call(event.target) }) } 小栗子 计算数组最大值 let arr = [1,2,3,4,2] console.log(Math.max.apply(Math,arr)) 小栗子3 动态拼接get参数 function Request() { this.get = function (params) { let str = Object.keys(params) .map(k => `${k}=${params[k]}`) .join('&') return `${this.url}?${str}` } } function Book() { this.url = \"https://www.baidu.com/book\" Request.call(this) } let book = new Book(); // \"https://www.baidu.com/book?id=1&name=书籍1\" console.log(book.get({ id: 1, name: '书籍1' })) function User() { this.url = \"https://www.baidu.com/user\" Request.call(this) } let user = new User(); // \"https://www.baidu.com/user?id=2&name=用户2\" console.log(user.get({ id: 2, name: '用户2' })) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:51:21 "},"JavaScript/07闭包常用操作.html":{"url":"JavaScript/07闭包常用操作.html","title":"07闭包常用操作","keywords":"","body":"闭包 闭包特性获取 数组中属于某区间的元素let arr = [1,23,2312,123,123,65,4,3,2,13,423,234,2] function between(a,b){ return function(v){ return v >= a && v 闭包根据某字段进行排序let arr = [ {id:1,price:11,name:'商品1'}, {id:1,price:0,name:'商品6'}, {id:1,price:202,name:'商品14'}, {id:1,price:120,name:'商品32'}, {id:1,price:220,name:'商品8'}, ] function order(field,type = 'asc'){ return function(a,b){ if(type === 'asc') return a[field] > b[field] ? 1 : -1 return a[field] > b[field] ? -1 : 1 } } console.log(arr.sort(order('price','asc'))) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:57:40 "},"JavaScript/08对象常用操作.html":{"url":"JavaScript/08对象常用操作.html","title":"08对象常用操作","keywords":"","body":"对象？ 自己new的 展开语法 动态合并属性function upload(params){ let config = { type: '*.jpeg,*.png', size: 1000 }; config = {...config,...params} console.log(config) } upload({size:99}) 解构let user = {name:'测试',age:18} let {name,age} = user console.log(name) 复杂类型的解构let user = { name: 'test', lesson:{ title: 'javaScript' } } let {name,lesson:{title}} = user // 输出JavaScript console.log(title) 再复杂类型的解构let user = { name: 'test', lesson:{ title: 'javaScript', age:{ a: 1 } } } let {name,lesson:{title,age:{a}}} = user console.log(a) 小栗子值不存在使用默认值let user = {name:\"小白\",sex:1} let {name,sex,age=18} = user console.log(name,sex,age) 生成默认的divfunction createElement(options = {}){ let {width = 200,height = 100,backgroundColor = \"red\"} = options const div = document.createElement('div') div.style.width = width + 'px' div.style.height = height + 'px' div.style.backgroundColor = backgroundColor document.body.appendChild(div) } createElement({width:100}) 检测数组有没有某属性 arr.hasOwnProperty('lenght') 检测数组父级对象有没有某属性 console.log('concat' in obj) 改变原型链使a继承b let a = { name: '后盾人' } let b = { url: 'www.baidu.com' } Object.setPrototypeOf(a,b) console.log(a.url) console.log(a.hasOwnProperty('name')) console.log('url' in a) 动态计算生成对象属性 let id = 0 let obj = {} obj[`id-${++id}`] = id obj[`id-${++id}`] = id console.log(obj) 数组动态转换成对象 let arr = [{name:'小白',id:'A01'},{name:'小黑',id:'A02'}] let obj = arr.reduce(((obj,item,index)=>{ obj[`${item['id']}-${index}`] = item return obj }),{}) console.log(JSON.stringify(obj,null,2)) // 结果 { \"A01-0\": { \"name\": \"小白\", \"id\": \"A01\" }, \"A02-1\": { \"name\": \"小黑\", \"id\": \"A02\" } } assing 对象合并 let obj = Object.assign({a:1},{b:2}) console.log(JSON.stringify(obj)) // {\"a\":1,\"b\":2} for in对象遍历(只读) let obj = { name: '小白', age: 222 } for(const key in obj){ console.log(key,obj[key]) } for of 遍历数组对象 let arr = [{ name: '小白',age: 222},{ name: '小黑',age: 123}] for(const [key,value] of Object.entries(arr)){ console.log(key,JSON.stringify(value)) } 对象浅拷贝1 let a = {name:'小黑'} let b = Object.assign({},a) 对象浅拷贝2let a = {name:'小黑'} let b = {...a} console.log(a === b) 对象浅拷贝3 可以赋值的时候改变变量 let a = {name:'小黑'} let newObj = {} for(const key in a){ newObj[key] = a[newObj] } 对象深拷贝1 let obj1 = { id : 'vip1', user: { name : '小黑' } } function copy(object){ let res = {} for (const key in object){ res[key] = typeof object[key] === 'object' ? copy(object[key]) : object[key] } return res } let obj2 = copy(obj1) obj1.user.name = '小白' // 输出时 并不会因为改变了obj1的user属性 而影响到obj2 console.log(JSON.stringify(obj1)) console.log(JSON.stringify(obj2)) 对象深拷贝2 当对象中有数组时 需要另外处理 let obj1 = { id : 'vip1', user: { name : '小黑' }, arr:[{age:22}] } function copy(object){ let res = object instanceof Array?[]:{} for(const [k,v] of Object.entries(object)){ res[k] = typeof v==='object'?copy(v):v } return res } let obj2 = copy(obj1) obj1.user.name = '小白' console.log(JSON.stringify(obj1)) console.log(JSON.stringify(obj2)) 创建对象 工厂模式 function user(name){ return { name, show: function(){ console.log(name) } } } let u1 = user('小白') console.log(JSON.stringify(u1)) 创建对象 构造函数 function User(name){ this.name = name; this.show = function(){ console.log(this.name) } } let u1 = new User('小白') console.log(JSON.stringify(u1)) 利用闭包特性 使info 私有化 function User(name,age){ let data = {name,age} let info = function(){ return data.age > 50 ? '老年' : '青年' } this.show = function(){ console.log(data.name + info()) } } let u = new User('小白',22) console.log(u.show()) this.name = '小黑' u.info = function(){return} console.log(u.show()) 访问器 可以将函数绑定在属性上 let Lesson = { lists:[ {name: 'js',price: 100}, {name: 'js',price: 1020}, {name: 'js',price: 800}, ], get total(){ return this.lists.reduce((t,l)=> t+l.price,0) } } console.log(Lesson.total) 代理 在不改变函数本身的情况下增强函数功能 function factorial(num){ return num === 1 ? 1 : num * factorial(num - 1) } let proxy = new Proxy(factorial,{ apply(func,obj,args){ console.time('run') func.apply(this,args) console.timeEnd('runEnd') } }) proxy.apply({},[10000]) 小栗子 代理截取数组元素数据 const lessons = [ {title:'Java编程思想'}, {title:'JavaScript高级程序设计第四版'} ] let proxy = new Proxy(lessons,{ get(array,key){ const title = array[key].title; console.log(title); const len = 5; array[key].title= title.length > len ? title.substr(0,len) + '.'.repeat(3) : title return array[key] } }) console.log(proxy[1]) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:56:54 "},"JavaScript/09使用Proxy实现Vue双向绑定.html":{"url":"JavaScript/09使用Proxy实现Vue双向绑定.html","title":"09Proxy实现Vue双向绑定","keywords":"","body":"使用Proxy 手写实现Vue双向绑定 Document function View() { //设置代理拦截 传入两个参数 1 target 被代理的对象 2 handler 被代理对象上的自定义行为 let proxy = new Proxy( {}, { get(obj, property) { }, // obj = {} , property = title, value = input输入的值 set(obj, property, value) { obj[property] = value; document .querySelectorAll( `[v-model=\"${property}\"],[v-bind=\"${property}\"]` ) .forEach(el => { el.innerHTML = value; el.value = value; }); } } ); //初始化绑定元素事件 this.run = function () { // 查询包含v-model属性的元素 const els = document.querySelectorAll(\"[v-model]\"); els.forEach(item => { // 给元素绑定键盘抬起事件 item.addEventListener(\"keyup\", function () { // 代理属性值 即title proxy[this.getAttribute(\"v-model\")] = this.value; }); }); }; } let view = new View().run(); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:58:45 "},"JavaScript/10实现表单校验器.html":{"url":"JavaScript/10实现表单校验器.html","title":"10实现表单校验器","keywords":"","body":"自己实现表单校验器 Document body { padding: 50px; background: #34495e; } input { border: solid 10px #ddd; height: 30px; } .error { border: solid 10px red; } \"use strict\"; //验证处理类 class Validate { max(value, len) { return value.length = len; } isNumber(value) { return /^\\d+$/.test(value); } } //代理工厂 function makeProxy(target) { return new Proxy(target, { get(target, key) { return target[key]; }, set(target, key, el) { const rule = el.getAttribute(\"rule\"); const validate = new Validate(); let state = rule.split(\",\").every(rule => { const info = rule.split(\":\"); return validate[info[0]](el.value, info[1]); }); el.classList[state ? \"remove\":\"add\"](\"error\"); return true; } }); } const nodes = makeProxy(document.querySelectorAll(\"[validate]\")); nodes.forEach((item, i) => { item.addEventListener(\"keyup\", function() { nodes[i] = this; }); }); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:59:59 "},"JavaScript/11改变JSON数据内容.html":{"url":"JavaScript/11改变JSON数据内容.html","title":"11改变JSON数据内容","keywords":"","body":"改变JSON数据内容 let user = { id:\"1\", name:\"小白\" } let json = JSON.stringify(user) console.log(json) let obj = JSON.parse(json,(key,value)=>{ if(key === \"id\"){ value += \"Vip \" + value } return value }) console.log(JSON.stringify(obj)) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:02:25 "},"JavaScript/12原型常用操作.html":{"url":"JavaScript/12原型常用操作.html","title":"12原型常用操作","keywords":"","body":"原型 使用console.dir() 可以打印对象属性和方法 根据某实例化对象 生成一个新的对象 function User(name){ this.name = name } let u1 = new User('小白') console.log(u1) // 根据已有对象创建新的对象 function createByObject(obj,...args){ const constructor = Object.getPrototypeOf(obj).constructor; return new constructor(...args) } let u2 = createByObject(u1,'小黑') console.log(u2) instanceof 判断构造函数的Prototype是否来自某对象 function A(){} let a = new A() // true console.log(a instanceof A) isPrototypeOf 明确判断此对象是否为另外一个对象原型链中的一份子 let a = {} let b = {} Object.setPrototypeOf(a,b) console.log(b.isPrototypeOf(a)) in 判断属性是否存在于对象 或 对象的原型链中 let a = {name:'小白'} Object.prototype.age = 22 // true console.log(\"age\" in a) hasOwnProperty 只判断当前对象是否包含某属性 let a = {name:'小白'} Object.prototype.age = 22 // false console.log(a.hasOwnProperty(\"age\")) apply借用其他对象原型的方法 会分散传参 [1,2,3]变成1,2,3 let o1 = { data: [1,23,4,312,23] } // 给o1 添加max方法 Object.setPrototypeOf(o1,{ max(){ return this.data.sort((a,b)=> b-a )[0] } }) console.log(o1.max()) let o2 = { lessons:{js:99,Java:100,vue:10}, get data(){ return Object.values(this.lessons) } } // 借用一下obj1对象的max方法 console.log(o1.max.apply(o2)) 使用call 借用其他对象原型的方法 数组还是数组[1,2,3] let o1 = { data: [1,23,4,312,23] } // 给o1 添加max方法 Object.setPrototypeOf(o1,{ max(data){ return data.sort((a,b)=> b-a )[0] } }) console.log(o1.max(o1.data)) let o2 = { lessons:{js:99,Java:100,vue:10} } // 借用一下obj1对象的max方法 console.log(o1.max.call(null,Object.values(o2.lessons))) 优化代码 直接使用Math.max let o1 = { data: [1,23,4,312,23] } console.log(Math.max.apply(null,o1.data)) // 使用call可以解构传参 console.log(Math.max.apply(null,...o1.data)) 小栗子 获取页面元素包含某属性的节点 a b // 过滤获取有clss属性的按钮 let btns = document.querySelectorAll(\"button\") btns = Array.prototype.filter.call(btns,item=>{ return item.hasAttribute(\"class\") }) console.log(btns) 注意 this和原型没有多大关系 他用于指向调用属性的当前对象 历史原因 有另外两种原型指向 Object.create() 只能设置不能获取 所以有了非标准的 浏览器厂商自己研究出来的 proto 有值获取 没值设置 推荐使用官方 Object.setPrototypeOf() xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:03:52 "},"JavaScript/13模块常用操作.html":{"url":"JavaScript/13模块常用操作.html","title":"13模块常用操作","keywords":"","body":"模块 自己写一个模块引擎 let module = (function() { //模块列表集合 const moduleLists = {}; function define(name, modules, action) { modules.map((m, i) => { modules[i] = moduleLists[m]; }); //执行并保存模块 moduleLists[name] = action.apply(null, modules); } return { define }; })(); //声明模块不依赖其它模块 module.define(\"hd\", [], function() { return { show() { console.log(\"hd module show\"); } }; }); //声明模块时依赖其它模块 module.define(\"xj\", [\"hd\"], function(hd) { hd.show(); }); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:04:41 "},"JavaScript/14异步常用操作.html":{"url":"JavaScript/14异步常用操作.html","title":"14异步常用操作","keywords":"","body":"异步 JS任务执行顺序 /** *> \"promise里面\" *> \"后盾人\" *> \"promise 成功\" *> \"setTimeout\" */ setTimeout(()=>{ // 4 宏任务最后执行 console.log(\"setTimeout\") },0) new Promise(resole =>{ resole() // 1 同步代码顺序执行 console.log(\"promise里面\") }).then(value => // 3 主任务结束执行微任务 console.log(\"promise 成功\") ) // 2 同步代码顺序执行 console.log(\"后盾人\") 自己封装Ajax function ajax(url){ return new Promise((resolve,reject)=>{ let xhr = new XMLHttpRequest(); xhr.open(\"GET\",url) xhr.send() xhr.onload = function(){ if(this.status === 200){ resolve(JSON.parse(this.response)) }else{ reject('加载失败') } } xhr.onerror = function(){reject(this)} }) } ajax('http://www.baidu.com') .then(res=>{console.log(res)}) .catch(err => {console.log(err)}) 自定义异常 class ParamError extends Error { constructor(msg) { super(msg), this.name = \"ParamError\" } } class HttpError extends Error { constructor(msg) { super(msg), this.name = \"HttpError\" } } function ajax(url) { return new Promise((resolve, reject) => { if (!/^http/.test(url)) { throw new ParamError('地址格式错误') } let xhr = new XMLHttpRequest(); xhr.open(\"GET\", url) xhr.send() xhr.onload = function () { if (this.status === 200) { resolve(JSON.parse(this.response)) } else if (this.status === 404) { reject(new HttpError('请求地址不存在')) }else { reject('加载失败') } } xhr.onerror = function () { reject(this) } }) } ajax('http://localhost') .then(res => { console.log(res) }) .catch(err => { if(err instanceof ParamError){ alert(err.message) } if(err instanceof HttpError){ alert(err.message) } }) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:06:34 "},"Java/":{"url":"Java/","title":"Java","keywords":"","body":"Java xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 16:43:32 "},"Java/01多线程/":{"url":"Java/01多线程/","title":"01多线程","keywords":"","body":"多线程 xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:14:45 "},"Java/01多线程/00Synchronized详解.html":{"url":"Java/01多线程/00Synchronized详解.html","title":"00Synchronized","keywords":"","body":"Synchronized详解 Synchronized 的作用 官网解释 同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的 果然 看完感觉跟没看一样 自己理解 用Synchronized修饰的代码 可做到 保证在同一时刻只有一个线程执行这段代码（代码段变成原子性的，保证并发安全） Synchronized的两个用法 对象锁 同步代码块锁(自己指定锁对象) 方法锁(默认锁对象为this当前实例对象) /** * 对象锁实例1 代码块形式 */ public class SynchronizedObjectCodeBlock2 implements Runnable{ public void run() { synchronized(this){ try { System.out.println(\"对象锁代码块\" + Thread.currentThread().getName() ); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"对象锁代码块\" + Thread.currentThread().getName() + \"运行结束\"); } } public static void main(String[] args) { SynchronizedObjectCodeBlock2 block2 = new SynchronizedObjectCodeBlock2(); Thread thread01 = new Thread(block2); Thread thread02 = new Thread(block2); thread01.start(); thread02.start(); } } /** *对象锁实例 方法锁 */ public class SynchronizedObjectMethod implements Runnable { public synchronized void mymethod(){ System.out.println(\"对像锁 锁方法\" +Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"执行结束\"); } @Override public void run(){ mymethod(); } static SynchronizedObjectMethod smethod = new SynchronizedObjectMethod(); public static void main(String[] args) { Thread thread1 = new Thread(smethod); Thread thread2 = new Thread(smethod); thread1.start(); thread2.start(); } } 类锁 指synchronized修饰静态的方法或指定锁为Class对象 概念(Java类可能会有很多实例对象,但只会有一个Class对象 所谓类锁本质上就是Class对象的锁而已,类锁只能在同一时刻被一个对象拥有) 形式1: synchronized加在static方法上 /** * 类锁 static形式 */ public class SynchronizedClassStatic implements Runnable { @Override public void run(){ method(); } static SynchronizedClassStatic synchronizedClassStatic1 = new SynchronizedClassStatic(); static SynchronizedClassStatic synchronizedClassStatic2 = new SynchronizedClassStatic(); public static synchronized void method(){ System.out.println(\"类锁形式1: static形式\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"运行结束!\"); } public static void main(String[] args) { Thread thread1 = new Thread(synchronizedClassStatic1); Thread thread2 = new Thread(synchronizedClassStatic2); thread1.start(); thread2.start(); } } 形式2: synchronized加在(*.class)代码块上 /** * .class */ public class SynchronizedClassClass implements Runnable{ @Override public void run() { method(); } private void method(){ synchronized (SynchronizedClassClass.class){ System.out.println(\"synchronized(*.class)\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"执行结束!\"); } } static SynchronizedClassClass synchronizedClassClass1 = new SynchronizedClassClass(); static SynchronizedClassClass synchronizedClassClass2 = new SynchronizedClassClass(); public static void main(String[] args) { Thread thread1 = new Thread(synchronizedClassClass1); Thread thread2 = new Thread(synchronizedClassClass2); thread1.start(); thread2.start(); } } xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:18:32 "},"Java/01多线程/01两种方式实现多线程.html":{"url":"Java/01多线程/01两种方式实现多线程.html","title":"01两种方式实现多线程","keywords":"","body":"两种方式实现多线程（Oracle文档） 1 实现Runnable接口 /** * @author :xzr * @date :2019-10-11 * @description :Runnable 方式实现线程 */ public class RunnableStyle implements Runnable{ @Override public void run() { System.out.println(\"实现Runnble接口 实现多线程\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableStyle()); thread.run(); } } 2 继承Thread类 /** * @author :xzr * @date :2019-10-==11== * @description :继承Thread类实现多线程 */ public class ThreadStyle extends Thread { @Override public void run() { System.out.println(\"继承Thread类实现多线程\"); } public static void main(String[] args) { new ThreadStyle().start(); } } 优先考虑实现Runnable接口来实现多线程 代码架构角度 具体的run方法应该和创建运行线程的机制（Thread类）解耦，用runnable可以实现解耦 继承Thread，每次新建任务只能新建一个独立线程，损耗比较大，用Runnable和线程池可以减小损耗 Java不支持双继承，继承了Runnable则不能继承其他类，限制了可拓展性 两种方式都重写了run方法 他们有什么不一样 Runnable最终调用的是target.run() 继承Thred 子类继承父类 整个run()方法被重写 以下是Thread 方法的run方法 /** * private Runnable target; * target 是一个Runner接口 */ @Override public void run() { if (target != null) { target.run(); } } 3 其他创建线程的方式 本质上实现多线程只有以上两种 其他的只是将其再次包装而已 Lambda 表达式的方式 /** * @author :xzr * @date :2019-10-11 * @description :Lambda 表达式创建线程 */ public class MyLambda { public static void main(String[] args) { new Thread(() -> System.out.println(Thread.currentThread().getName()) ).start(); } } 线程池的方式 /** * @author :xzr * @date :2019-10-11 * @description :线程池创建线程的方法 */ public class MyThreadPool { public static void main(String[] args) { // 创建一个线程池 ExecutorService executorService = Executors.newCachedThreadPool(); // 往线程池添加任务 for (int i = 0; i 定时器的方式 /** * @author :xzr * @date :2019-10-11 * @description :定时器创建多线程 */ public class MyTimmerTask { public static void main(String[] args) { Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }, 1000, 1000); } } 匿名内部类的方式 /** * @author :xzr * @date :2019-10-11 * @description :匿名内部类实现多线程 */ public class MyAnonymity { public static void main(String[] args) { new Thread() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }.start(); new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }).start(); } } xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:23:23 "},"Java/01多线程/02start与run.html":{"url":"Java/01多线程/02start与run.html","title":"02start()与run()","keywords":"","body":"start()方法 与 run()方法 start() 方法的含义 1. 启动新线程：通知jvm在空闲的时候启动线程 2. 准备工作： 3. 不能重复执行start():会抛```java.lang.IllegalThreadStateException``` 异常 start源码解析 start方法是被synchronized方法修饰的,可以保证线程安全 由JVM创建的main方法线程和system组线程，并不会通过start来启动 start0是一个native方法 是由C和C++实现的 不在此次研究范围 public synchronized void start() { // 1 检查线程状态 不是新线程会抛出异常 if (threadStatus != 0) throw new IllegalThreadStateException(); // 2 将当前线程加入线程组 group.add(this); boolean started = false; try { // 3 调用start0()方法启动线程 start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:31:35 "},"Java/01多线程/03停止线程.html":{"url":"Java/01多线程/03停止线程.html","title":"03停止线程","keywords":"","body":"停止线程(interrupt) 如何停止线程？ A. 用volatile的boolean作为标记来停止 B. 用stop()方法让线程停止 C. 用interrupt来请求线程停止 解答： 应该选C。原理：用interrupt来请求线程的停止而不是强制退出，好处是比较安全 想停止线程，要请求方，被停止方，子方法被调用方 互相配合 A 作为被停止方,在合适的时候检查中断信号，并在可能会抛出InterrupedException的时候处理该中断信号 B 作为被请求方：发出中断信号 C 子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态 最后再说错误的方法： - 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况 如何处理无法响应中断时如何停止线程？ A. 用interrupt方法来请求停止线程 B. 不可中断的阻塞无法处理 C. 根据不同的类调用不同的方法 解答： 应该选C。 如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程。 但是对于不能响应InterruptedException的阻塞，很遗憾，并没有一个通用的解决方案。 但是我们可以利用特定的其它的可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。 答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。 总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药 xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:28:37 "},"Java/01多线程/04线程的生命周期.html":{"url":"Java/01多线程/04线程的生命周期.html","title":"04线程的生命周期","keywords":"","body":"线程的生命周期（六个状态） 6种状态 New(新创建) Runnable(可运行的) Blocked(被阻塞) Waiting(等待) Timed Waiting(计时等待) Terminated(已终止) 获取线程状态New、Runnable、Terminate /** * @author :xzr * @date :2019-10-15 * @description : 展示线程的New、Runnable、Terminated状态 * 即使是正在运行也是Runnable而不是Running */ public class NewRunnableTerminated implements Runnable{ public static void main(String[] args) throws InterruptedException{ Thread thread = new Thread(new NewRunnableTerminated()); // 线程刚刚创建 1 NEW System.out.println(thread.getState()); // 线程启动 2 RUNNABLE thread.start(); System.out.println(thread.getState()); // 线程运行时状态 (休眠也算是运行是在运行了，只会有Runnable状态，不会有Running) Thread.sleep(1); System.out.println(thread.getState()); // 线程正常执行完毕 3 TERMINATED Thread.sleep(1000); System.out.println(thread.getState()); } @Override public void run() { for (int i = 0; i 阻塞状态是什么 xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:29:10 "},"Java/01多线程/05Thread和Object中重要方法详解.html":{"url":"Java/01多线程/05Thread和Object中重要方法详解.html","title":"05Thread和Object中重要方法详解","keywords":"","body":"Thread和Object中重要方法详解 xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:29:46 "},"Java/01多线程/06线程池.html":{"url":"Java/01多线程/06线程池.html","title":"06线程池","keywords":"","body":"线程池 是什么东西 见名知意存放线程的池子。 为什么要用。 在并发场景中，如果有大量的并发请求进入，在短时间内大量的创建销毁线程可能会导致系统奔溃，这个时候就需要线程池来控制线程，节省资源。 怎么用 不推荐每个业务都创建 一个系统中推荐有两个线程池 即核心业务一个非核心业务一个 用法1 public class ThreadPool { class MyRunable implements Runnable{ public void run() { System.out.println(\"hi\"); } } @Test public void Test1(){ //创建线程池默认10个线程 注意线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.submit(new MyRunable()); } } 用法2 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:31:34 "}}