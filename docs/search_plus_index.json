{"./":{"url":"./","title":"前言","keywords":"","body":"30SecondsCode 30秒代码 整理一下平时记录在有道云用到的东西 方便下次使用 gitPages 线上浏览 https://xiaozhaorong.github.io/30SecondsCode/index.html 安装淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装gitbook cnpm install gitbook -g 初始化书籍 gitbook init 本地预览书籍 gitbook serve 本地预览 http://localhost:4000 编译书籍 gitbook build . docs 安装gitBook 插件 gitbook install xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 17:05:25 "},"JavaScript/":{"url":"JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 16:44:01 "},"JavaScript/01字符串常用操作.html":{"url":"JavaScript/01字符串常用操作.html","title":"01字符串常用操作","keywords":"","body":"01常用的字符串转换 金额加￥ // -100 转换 -￥100 function formatMoney(money) { return money 字符串文字过长 截取换成... // 字符串文字过长 截取换成... function formatStr(str){ return str.length > 8 ? (str.substr(0,8) + '.'.repeat(3)) : str } formatStr('123456789') // 12345678... xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:20:09 "},"JavaScript/02正则常用操作.html":{"url":"JavaScript/02正则常用操作.html","title":"02正则常用操作","keywords":"","body":"正则 香不香 先看对比 不使用正则 在字符串中过滤数字// 不使用正则的情况下 在字符串中选出数字 let str = 'da231sda11213xvc312sfq23' let nums = [...str].filter(s => !Number.isNaN(parseInt(s))).join('') // 输出 2311121331223 console.log(nums) 使用的正则表达式let str = 'da231sda11213xvc312sfq23' // 使用正则表达式 选出数字 let nums2 = str.match(/\\d/g).join('') // 输出 2311121331223 console.log(nums2) 怎么用 使用对象创建正则表达式 不需要写字面量 let str = 'das12312adad' let reg = new RegExp('a','g') // 会返回true console.log(reg.test(str)) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:29:15 "},"JavaScript/03数组常用操作.html":{"url":"JavaScript/03数组常用操作.html","title":"03数组常用操作","keywords":"","body":"基础Api let arr = [] // push 加入数组尾部 返回长度 arr.push('a') // pop 从数组尾部移除 arr.pop() // unshift 追加到数组头部 返回长度 arr.unshift('b') // shift 从数组头部移除 arr.shift() 数组操作中间位置的元素 fill 数组指定位置替换数据let arr = [1,2,3,4].fill('空指针',1,4) // 运行结果 [1, \"空指针\", \"空指针\", \"空指针\"] console.log(arr) slice 截取指定位置的数组 返回新数组 不会改变原数组let arr = ['a','b','c','d'] // 运行结果 [\"b\", \"c\"] console.log(arr.slice(1,3)) splice 指定开始位置与需要截取几个元素 删除元素 会改变原数组let arr = ['a','b','c','d'] let tmp = arr.splice(1,1) // 运行结果已删除 [\"b\"] 原的数组 [\"a\", \"c\", \"d\"] console.log(tmp,arr) splice 指定定开始位置与需要截取几个元素 替换元素 会改变原数组let arr = [1,2,3,4] let tmp = arr.splice(1,2,'a') // 运行结果 [2, 3] [1, \"a\", 4] console.log(tmp,arr) splice 指定某个位置开始 增加元素let arr = [1,2,3,4] let tmp = arr.splice(2,0,'a') // 运行结果[] [1, 2, \"a\", 3, 4] console.log(tmp,arr) split 字符串拆分数组let tmp = 'a,b,c,d'.split(',') // 运行结果 [\"a\", \"b\", \"c\", \"d\"] console.log(tmp) join 按指定格式 将字符串合并成数组let str = ['a','b','c'].join('-') // 运行结果 \"a-b-c\" console.log(str) ... 两个数组合并 小栗子1let arr1 = ['a','b'] let arr2 = ['c','d'] let arr3 = [...arr1,...arr2] push 两个数组合并 小栗子2let arr1 = ['a','b'] let arr2 = ['c','d'] arr1.push(...arr2) concat 两个数组合并 小栗子3 let arr1 = ['a','b'] let arr2 = ['c','d'] arr1 = arr1.concat(arr2) copyWithin 将数组元素移动到指定位置 参数1 复制到指定元素的位置 参数2 要复制元素的开始位置 参数 要复制元素的结束位置 let arr = ['a','b','c','d','e'] console.log(arr.copyWithin(3,1,3)) 数组查找 indexOf 从左侧开始查找'c' 返回元素下标 let arr = ['a','b','c','d','e'] // 运行结果 c console.log(arr.indexOf('c')) includes 查找数组中是否包含元素 返回true || false let arr = ['a','b','c','d','e'] // 运行结果 true console.log(arr.includes('c')) find 查找对象 let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.find((item)=>{ return item.name === '小白' }) // 运行结果 { name: \"小白\", age: 18 } console.log(res) findIndex 返回元素下标let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.findIndex((item)=>{ return item.name === '小白' }) // 运行结果 0 console.log(res) 遍历对象数组拼接返回想要的元素let arr = [{name:'小白',age:18},{name:'小黑',age:20}] let res = arr.map((v) => v.name) // 运行结果 [\"小白\", \"小黑\"] console.log(res) 排序 sort 按价格从小到大排序let order = [ {name:'iphone',price:8000}, {name:'小米',price:5000}, {name:'华为',price:6000} ] order = order.sort((a,b)=>{ // b在前a在后从大到小排,a前b在后从小到大排 return a.price - b.price }) console.table(order) 循环 of 会返回值let arr = ['a','b','c'] // of 返回值 底层是用迭代器 iterator for(let v of arr){ console.log(v) } // 运行结果 > \"a\" > \"b\" > \"c\" in返回索引let arr = ['a','b','c'] for(let v in arr){ console.log(v) } // 运行结果 > \"0\" > \"1\" > \"2\" forEach item返回元素 index 返回下标let arr = ['a','b','c'] arr.forEach((item,index) => { console.log(index,item) }) // 运行结果 > 0 \"a\" > 1 \"b\" > 2 \"c\" iterator 迭代器 arr.values() 返回一个值迭代器对象let arr = ['a','b','c'] let values = arr.values() while(({value,done} = values.next() )&& done === false){ console.log(value) } // 运行结果 > \"a\" > \"b\" > \"c\" iterator 迭代器 arr.keys() 返回一个下标迭代器对象let arr = ['a','b','c'] let keys = arr.keys() while(({value,done} = keys.next() )&& done === false){ console.log(value) } // 运行结果 > 0 > 1 > 2 判断 every 用于判断数组元素是否全部符合条件let user = [{name:'a',js:99},{name:'b',js:66},{name:'c',js:89}] // every 用于判断数组元素是否全部符合条件 let res = user.every(function(item) { return item.js >= 60 }) // 运行结果 true console.log(res) some 数组中一个值为真 则返回真let user = [{name:'a',js:99},{name:'b',js:66},{name:'c',js:89}] // some 用于判断数组元素是否全部符合条件 let res = user.some((item)=>{ return item.js >= 60 }) // 运行结果 true console.log(res) filter 过滤 查询不等于'b'的数据let arr = ['a','b','b','d'] let newArr = arr.filter((item)=>{ return item != 'b' }) // 运行结果 [\"a\", \"d\"] console.log(newArr) 自己实现filterfunction filter(array,callback){ let newArray = [] for(const v of array){ if(callback(v) === true){ newArray.push(v) } } return newArray } let arr = ['a','b','c','a','d','a'] let tmp = filter(arr,(item)=>{return item != 'a'}) // 运行结果 [\"b\", \"c\", \"d\"] console.log(tmp) reduce 小栗子1 统计a字符出现的次数let arr = ['a','b','c','a','a'] // 使用reduce 统计某字符出现的字数 let res = arr.reduce((total,cur)=>{ total += 'a' === cur ? 1:0 return total },0) // 运行结果 3 console.log(res) reuce 小栗子2 计算订单总数let order = [ {name:'iphone',price:8000}, {name:'小米',price:5000}, {name:'华为',price:6000} ] // 计算订单总数 let sum = order.reduce(((total,cur)=>{ return (total += cur['price']) }),0) // 运行结果 19000 console.log(sum) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:32:11 "},"JavaScript/04Date常用操作.html":{"url":"JavaScript/04Date常用操作.html","title":"04Date常用操作","keywords":"","body":" 获取两个日期相差的天数 //参数格式 2020-11-11 获取两个日期相差的天数 differDay(start, end) { console.log(start, end) return (Date.parse(start) - Date.parse(end)) / (24 * 3600 * 1000) }, xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:48:55 "},"JavaScript/05ES6新增对象.html":{"url":"JavaScript/05ES6新增对象.html","title":"05ES6新增对象","keywords":"","body":"Symbol 是什么 产生一个唯一的数据 为什么 特殊情况下 有两个一模一样的值 在不改变其值的情况下,使其独立存在 怎么用 声明n次 会出现n个不一样的let s = Symbol('一只空指针') //运行结果 一只空指针 console.log(s.description) 声明n次 只会出现一个一样的 for of / for in 不能遍历到Symbol里面的值 所以可以用来当私有属性 解除字符串耦合的问题 let user1 = { name: '小白1', key: Symbol() } let user2 = { name: '小白1', key: Symbol() } let grade = { [user1.key]: {js:100,css:99}, [user2.key]: {js:20,css:29} } console.log(grade[user1.key]) Set类型 是什么 ES6 新增的数据结构 与数组类型，但是当元素为值类型时 会自动去重 怎么用let s = new Set() s.add(1) s.add(1) // 运行结果 输出1 console.log(s) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:48:46 "},"JavaScript/06函数常用操作.html":{"url":"JavaScript/06函数常用操作.html","title":"06函数常用操作","keywords":"","body":"函数 函数给默认值 数组排序小栗子function sortArray(array,type='asc'){ return array.sort((a,b)=>{ return type === 'asc' ? a-b:b-a; }) } arr = [1,23,32,1,32,43,6] console.log(sortArray(arr)) arguments 参数数量不确定 在函数内部获取到参数function sum(){ return [...arguments].reduce((a,b)=>a+b) } console.log(sum(1,2,3,4,5)) 相同解决方案 用...语法function sum(...args){ return args.reduce((a,b)=>a+b) } console.log(sum(1,2,3,4,5)) 箭头函数简写 筛选数组let arr = [1,23,43,32,3,123,3,2,1,23,5].filter(value=>value 递个龟 写个n的阶乘吧function factorial(num){ return num === 1 ? 1 : num * factorial(--num) } console.log(factorial(5)) 再递个龟 写个数组求和 function sum(...args){ return args.length === 0 ? 0 : args.pop() + sum(...args) } console.log(sum(1,2,3,5)) this指向 name = '小黑' let edu = { name: '小白', show: function(){ //有对象引用 输出edu对象 console.log('外层',this.name) function render(){ //无对象引用 输出window对象 console.log('内层',this.name) } render() } } edu.show() 多层函数获取外部this指向 可以用 变量 self 暂存 let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ const self = this; return this.lists.map((v)=>{ console.log(self.site + v) }) } } Lesson.show() map函数可以 多传一个参数 将this传入 那么就不需要 第三方变量暂存了let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ return this.lists.map(function(v){ console.log(this.site + v) },this) } } Lesson.show() 箭头函数 会改变this指向所以可以直接获取到外部的this let Lesson = { site: '课程表：', lists: ['js','css','mysql'], show: function(){ return this.lists.map((v)=>{ console.log(this.site + v) }) } } Lesson.show() 闭包面试题 以下代码输出什么 var name = \"W\" var obj = { name:\"My Object\", getName: function(){ return function(){ return this.name } } } // return this.name 没有绑定对象 默认指向window 输出W console.log(obj.getName()()) // ------------------------------ var name = \"W2\" var obj = { name: \"W Obj\", getName: function(){ var that = this; return function(){ return that.name } } } // that保存了外部的this指向 输出\"W Obj\" console.log(obj.getName()()) call 改变this指向 立即执行 function User(name){this.name = name;} let lisi = new User('李四') console.log(lisi) let u = {age: 22} // 默认会调用构造函数 生成{}对象 往里面添加属性 call 会 将this指针指向传入对象 基于已有对象添加属性 User.call(u,\"测试\") console.log(u) apply 也是改变this指向 区别 不会立即执行 在构造函数有参数时 传参不同 let lisi = { name: '李四' } let ww = { name: '王五' } function User(age){ console.log(this.name + ':' + age) } User.call(lisi,22) // apply 传递的是数组 User.apply(ww,[11]) bind 改变this指向 不会立即执行 小栗子 动态改变show this里面的值 btn1 btn2 btn3 function show() { alert(this.innerHTML) } let btns = document.querySelectorAll('button') for (let i = 0; i { show.call(event.target) }) } 小栗子 计算数组最大值 let arr = [1,2,3,4,2] console.log(Math.max.apply(Math,arr)) 小栗子3 动态拼接get参数 function Request() { this.get = function (params) { let str = Object.keys(params) .map(k => `${k}=${params[k]}`) .join('&') return `${this.url}?${str}` } } function Book() { this.url = \"https://www.baidu.com/book\" Request.call(this) } let book = new Book(); // \"https://www.baidu.com/book?id=1&name=书籍1\" console.log(book.get({ id: 1, name: '书籍1' })) function User() { this.url = \"https://www.baidu.com/user\" Request.call(this) } let user = new User(); // \"https://www.baidu.com/user?id=2&name=用户2\" console.log(user.get({ id: 2, name: '用户2' })) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:51:21 "},"JavaScript/07闭包常用操作.html":{"url":"JavaScript/07闭包常用操作.html","title":"07闭包常用操作","keywords":"","body":"闭包 闭包特性获取 数组中属于某区间的元素let arr = [1,23,2312,123,123,65,4,3,2,13,423,234,2] function between(a,b){ return function(v){ return v >= a && v 闭包根据某字段进行排序let arr = [ {id:1,price:11,name:'商品1'}, {id:1,price:0,name:'商品6'}, {id:1,price:202,name:'商品14'}, {id:1,price:120,name:'商品32'}, {id:1,price:220,name:'商品8'}, ] function order(field,type = 'asc'){ return function(a,b){ if(type === 'asc') return a[field] > b[field] ? 1 : -1 return a[field] > b[field] ? -1 : 1 } } console.log(arr.sort(order('price','asc'))) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:57:40 "},"JavaScript/08对象常用操作.html":{"url":"JavaScript/08对象常用操作.html","title":"08对象常用操作","keywords":"","body":"对象？ 自己new的 展开语法 动态合并属性function upload(params){ let config = { type: '*.jpeg,*.png', size: 1000 }; config = {...config,...params} console.log(config) } upload({size:99}) 解构let user = {name:'测试',age:18} let {name,age} = user console.log(name) 复杂类型的解构let user = { name: 'test', lesson:{ title: 'javaScript' } } let {name,lesson:{title}} = user // 输出JavaScript console.log(title) 再复杂类型的解构let user = { name: 'test', lesson:{ title: 'javaScript', age:{ a: 1 } } } let {name,lesson:{title,age:{a}}} = user console.log(a) 小栗子值不存在使用默认值let user = {name:\"小白\",sex:1} let {name,sex,age=18} = user console.log(name,sex,age) 生成默认的divfunction createElement(options = {}){ let {width = 200,height = 100,backgroundColor = \"red\"} = options const div = document.createElement('div') div.style.width = width + 'px' div.style.height = height + 'px' div.style.backgroundColor = backgroundColor document.body.appendChild(div) } createElement({width:100}) 检测数组有没有某属性 arr.hasOwnProperty('lenght') 检测数组父级对象有没有某属性 console.log('concat' in obj) 改变原型链使a继承b let a = { name: '后盾人' } let b = { url: 'www.baidu.com' } Object.setPrototypeOf(a,b) console.log(a.url) console.log(a.hasOwnProperty('name')) console.log('url' in a) 动态计算生成对象属性 let id = 0 let obj = {} obj[`id-${++id}`] = id obj[`id-${++id}`] = id console.log(obj) 数组动态转换成对象 let arr = [{name:'小白',id:'A01'},{name:'小黑',id:'A02'}] let obj = arr.reduce(((obj,item,index)=>{ obj[`${item['id']}-${index}`] = item return obj }),{}) console.log(JSON.stringify(obj,null,2)) // 结果 { \"A01-0\": { \"name\": \"小白\", \"id\": \"A01\" }, \"A02-1\": { \"name\": \"小黑\", \"id\": \"A02\" } } assing 对象合并 let obj = Object.assign({a:1},{b:2}) console.log(JSON.stringify(obj)) // {\"a\":1,\"b\":2} for in对象遍历(只读) let obj = { name: '小白', age: 222 } for(const key in obj){ console.log(key,obj[key]) } for of 遍历数组对象 let arr = [{ name: '小白',age: 222},{ name: '小黑',age: 123}] for(const [key,value] of Object.entries(arr)){ console.log(key,JSON.stringify(value)) } 对象浅拷贝1 let a = {name:'小黑'} let b = Object.assign({},a) 对象浅拷贝2let a = {name:'小黑'} let b = {...a} console.log(a === b) 对象浅拷贝3 可以赋值的时候改变变量 let a = {name:'小黑'} let newObj = {} for(const key in a){ newObj[key] = a[newObj] } 对象深拷贝1 let obj1 = { id : 'vip1', user: { name : '小黑' } } function copy(object){ let res = {} for (const key in object){ res[key] = typeof object[key] === 'object' ? copy(object[key]) : object[key] } return res } let obj2 = copy(obj1) obj1.user.name = '小白' // 输出时 并不会因为改变了obj1的user属性 而影响到obj2 console.log(JSON.stringify(obj1)) console.log(JSON.stringify(obj2)) 对象深拷贝2 当对象中有数组时 需要另外处理 let obj1 = { id : 'vip1', user: { name : '小黑' }, arr:[{age:22}] } function copy(object){ let res = object instanceof Array?[]:{} for(const [k,v] of Object.entries(object)){ res[k] = typeof v==='object'?copy(v):v } return res } let obj2 = copy(obj1) obj1.user.name = '小白' console.log(JSON.stringify(obj1)) console.log(JSON.stringify(obj2)) 创建对象 工厂模式 function user(name){ return { name, show: function(){ console.log(name) } } } let u1 = user('小白') console.log(JSON.stringify(u1)) 创建对象 构造函数 function User(name){ this.name = name; this.show = function(){ console.log(this.name) } } let u1 = new User('小白') console.log(JSON.stringify(u1)) 利用闭包特性 使info 私有化 function User(name,age){ let data = {name,age} let info = function(){ return data.age > 50 ? '老年' : '青年' } this.show = function(){ console.log(data.name + info()) } } let u = new User('小白',22) console.log(u.show()) this.name = '小黑' u.info = function(){return} console.log(u.show()) 访问器 可以将函数绑定在属性上 let Lesson = { lists:[ {name: 'js',price: 100}, {name: 'js',price: 1020}, {name: 'js',price: 800}, ], get total(){ return this.lists.reduce((t,l)=> t+l.price,0) } } console.log(Lesson.total) 代理 在不改变函数本身的情况下增强函数功能 function factorial(num){ return num === 1 ? 1 : num * factorial(num - 1) } let proxy = new Proxy(factorial,{ apply(func,obj,args){ console.time('run') func.apply(this,args) console.timeEnd('runEnd') } }) proxy.apply({},[10000]) 小栗子 代理截取数组元素数据 const lessons = [ {title:'Java编程思想'}, {title:'JavaScript高级程序设计第四版'} ] let proxy = new Proxy(lessons,{ get(array,key){ const title = array[key].title; console.log(title); const len = 5; array[key].title= title.length > len ? title.substr(0,len) + '.'.repeat(3) : title return array[key] } }) console.log(proxy[1]) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:56:54 "},"JavaScript/09使用Proxy实现Vue双向绑定.html":{"url":"JavaScript/09使用Proxy实现Vue双向绑定.html","title":"09Proxy实现Vue双向绑定","keywords":"","body":"使用Proxy 手写实现Vue双向绑定 Document function View() { //设置代理拦截 传入两个参数 1 target 被代理的对象 2 handler 被代理对象上的自定义行为 let proxy = new Proxy( {}, { get(obj, property) { }, // obj = {} , property = title, value = input输入的值 set(obj, property, value) { obj[property] = value; document .querySelectorAll( `[v-model=\"${property}\"],[v-bind=\"${property}\"]` ) .forEach(el => { el.innerHTML = value; el.value = value; }); } } ); //初始化绑定元素事件 this.run = function () { // 查询包含v-model属性的元素 const els = document.querySelectorAll(\"[v-model]\"); els.forEach(item => { // 给元素绑定键盘抬起事件 item.addEventListener(\"keyup\", function () { // 代理属性值 即title proxy[this.getAttribute(\"v-model\")] = this.value; }); }); }; } let view = new View().run(); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:58:45 "},"JavaScript/10实现表单校验器.html":{"url":"JavaScript/10实现表单校验器.html","title":"10实现表单校验器","keywords":"","body":"自己实现表单校验器 Document body { padding: 50px; background: #34495e; } input { border: solid 10px #ddd; height: 30px; } .error { border: solid 10px red; } \"use strict\"; //验证处理类 class Validate { max(value, len) { return value.length = len; } isNumber(value) { return /^\\d+$/.test(value); } } //代理工厂 function makeProxy(target) { return new Proxy(target, { get(target, key) { return target[key]; }, set(target, key, el) { const rule = el.getAttribute(\"rule\"); const validate = new Validate(); let state = rule.split(\",\").every(rule => { const info = rule.split(\":\"); return validate[info[0]](el.value, info[1]); }); el.classList[state ? \"remove\":\"add\"](\"error\"); return true; } }); } const nodes = makeProxy(document.querySelectorAll(\"[validate]\")); nodes.forEach((item, i) => { item.addEventListener(\"keyup\", function() { nodes[i] = this; }); }); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 19:59:59 "},"JavaScript/11改变JSON数据内容.html":{"url":"JavaScript/11改变JSON数据内容.html","title":"11改变JSON数据内容","keywords":"","body":"改变JSON数据内容 let user = { id:\"1\", name:\"小白\" } let json = JSON.stringify(user) console.log(json) let obj = JSON.parse(json,(key,value)=>{ if(key === \"id\"){ value += \"Vip \" + value } return value }) console.log(JSON.stringify(obj)) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:02:25 "},"JavaScript/12原型常用操作.html":{"url":"JavaScript/12原型常用操作.html","title":"12原型常用操作","keywords":"","body":"原型 使用console.dir() 可以打印对象属性和方法 根据某实例化对象 生成一个新的对象 function User(name){ this.name = name } let u1 = new User('小白') console.log(u1) // 根据已有对象创建新的对象 function createByObject(obj,...args){ const constructor = Object.getPrototypeOf(obj).constructor; return new constructor(...args) } let u2 = createByObject(u1,'小黑') console.log(u2) instanceof 判断构造函数的Prototype是否来自某对象 function A(){} let a = new A() // true console.log(a instanceof A) isPrototypeOf 明确判断此对象是否为另外一个对象原型链中的一份子 let a = {} let b = {} Object.setPrototypeOf(a,b) console.log(b.isPrototypeOf(a)) in 判断属性是否存在于对象 或 对象的原型链中 let a = {name:'小白'} Object.prototype.age = 22 // true console.log(\"age\" in a) hasOwnProperty 只判断当前对象是否包含某属性 let a = {name:'小白'} Object.prototype.age = 22 // false console.log(a.hasOwnProperty(\"age\")) apply借用其他对象原型的方法 会分散传参 [1,2,3]变成1,2,3 let o1 = { data: [1,23,4,312,23] } // 给o1 添加max方法 Object.setPrototypeOf(o1,{ max(){ return this.data.sort((a,b)=> b-a )[0] } }) console.log(o1.max()) let o2 = { lessons:{js:99,Java:100,vue:10}, get data(){ return Object.values(this.lessons) } } // 借用一下obj1对象的max方法 console.log(o1.max.apply(o2)) 使用call 借用其他对象原型的方法 数组还是数组[1,2,3] let o1 = { data: [1,23,4,312,23] } // 给o1 添加max方法 Object.setPrototypeOf(o1,{ max(data){ return data.sort((a,b)=> b-a )[0] } }) console.log(o1.max(o1.data)) let o2 = { lessons:{js:99,Java:100,vue:10} } // 借用一下obj1对象的max方法 console.log(o1.max.call(null,Object.values(o2.lessons))) 优化代码 直接使用Math.max let o1 = { data: [1,23,4,312,23] } console.log(Math.max.apply(null,o1.data)) // 使用call可以解构传参 console.log(Math.max.apply(null,...o1.data)) 小栗子 获取页面元素包含某属性的节点 a b // 过滤获取有clss属性的按钮 let btns = document.querySelectorAll(\"button\") btns = Array.prototype.filter.call(btns,item=>{ return item.hasAttribute(\"class\") }) console.log(btns) 注意 this和原型没有多大关系 他用于指向调用属性的当前对象 历史原因 有另外两种原型指向 Object.create() 只能设置不能获取 所以有了非标准的 浏览器厂商自己研究出来的 proto 有值获取 没值设置 推荐使用官方 Object.setPrototypeOf() xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:03:52 "},"JavaScript/13模块常用操作.html":{"url":"JavaScript/13模块常用操作.html","title":"13模块常用操作","keywords":"","body":"模块 自己写一个模块引擎 let module = (function() { //模块列表集合 const moduleLists = {}; function define(name, modules, action) { modules.map((m, i) => { modules[i] = moduleLists[m]; }); //执行并保存模块 moduleLists[name] = action.apply(null, modules); } return { define }; })(); //声明模块不依赖其它模块 module.define(\"hd\", [], function() { return { show() { console.log(\"hd module show\"); } }; }); //声明模块时依赖其它模块 module.define(\"xj\", [\"hd\"], function(hd) { hd.show(); }); xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:04:41 "},"JavaScript/14异步常用操作.html":{"url":"JavaScript/14异步常用操作.html","title":"14异步常用操作","keywords":"","body":"异步 JS任务执行顺序 /** *> \"promise里面\" *> \"后盾人\" *> \"promise 成功\" *> \"setTimeout\" */ setTimeout(()=>{ // 4 宏任务最后执行 console.log(\"setTimeout\") },0) new Promise(resole =>{ resole() // 1 同步代码顺序执行 console.log(\"promise里面\") }).then(value => // 3 主任务结束执行微任务 console.log(\"promise 成功\") ) // 2 同步代码顺序执行 console.log(\"后盾人\") 自己封装Ajax function ajax(url){ return new Promise((resolve,reject)=>{ let xhr = new XMLHttpRequest(); xhr.open(\"GET\",url) xhr.send() xhr.onload = function(){ if(this.status === 200){ resolve(JSON.parse(this.response)) }else{ reject('加载失败') } } xhr.onerror = function(){reject(this)} }) } ajax('http://www.baidu.com') .then(res=>{console.log(res)}) .catch(err => {console.log(err)}) 自定义异常 class ParamError extends Error { constructor(msg) { super(msg), this.name = \"ParamError\" } } class HttpError extends Error { constructor(msg) { super(msg), this.name = \"HttpError\" } } function ajax(url) { return new Promise((resolve, reject) => { if (!/^http/.test(url)) { throw new ParamError('地址格式错误') } let xhr = new XMLHttpRequest(); xhr.open(\"GET\", url) xhr.send() xhr.onload = function () { if (this.status === 200) { resolve(JSON.parse(this.response)) } else if (this.status === 404) { reject(new HttpError('请求地址不存在')) }else { reject('加载失败') } } xhr.onerror = function () { reject(this) } }) } ajax('http://localhost') .then(res => { console.log(res) }) .catch(err => { if(err instanceof ParamError){ alert(err.message) } if(err instanceof HttpError){ alert(err.message) } }) xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 20:06:34 "},"Java/":{"url":"Java/","title":"Java","keywords":"","body":"Java xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 16:43:32 "},"Java/01JMM与JVM.html":{"url":"Java/01JMM与JVM.html","title":"01JMM与JVM","keywords":"","body":"01 JMM与JVM Java是运行在虚拟机上面的，这也是为什么Java能跨平台运行的原因，作为Java程序的底层，了解JVM内存结构就显得很重要了。有一个很常见的误解,JVM内存结构与Java内存模型到底指的是不是同一个东西。其实他们不是同一个东西来的。（以下基于JDK1.8） JVM内存结构指的是一个规范，规范里面规定了JVM内存结构要有类装载子系统、方法区,Java堆，Java栈、线程计数器、本地方法栈、执行引擎。GC垃圾回收器这些东西。而各个不同JDK则是实现了这些规范，他们的Java内存模型,会有一些不一样。 用一张图表示JVM内存结构（图1） 了解基本概念之后可以开始看看主流的Java内存模型是长什么样的用一张图来表示（这张图画了好久 -- 图2） 口说无凭 通过一个小例子看看栈是怎么执行的/** * 一段简单的代码 一看便知道执行的结果是8 * 那在虚拟机底层这个 8 是怎么计算出来的呢 */ public class MyTest0 { public static void main(String[] args) { sum(); } static void sum() { int a = 5; int b = 3; System.out.println(a + b); } } 在当前Java文件的目录下输入 以下指令编译成MyTest0.class文件 javac MyTest0.java 这个时候会产生一个MyTest0.class的字节码文件，我们是看不懂的 截取一部分大概长这样子（不同的编码环境下 打开会不一样） 漱壕 4 \u001e \u0006 \u0010 \u0005 \u0011 \u0012 \u0013 \u0014 \u0015\u0007 \u0016\u0007 \u0017\u0001 \u0006\u0001 \u0003()V\u0001 \u0004Code\u0001 \u000fLineNumberTable\u0001 \u0004main\u0001 \u0016([Ljava/lang/String;)V\u0001 \u0003sum\u0001 SourceFile\u0001 可以使用以下指令对class文件进行反编译，在控制台输出反编译后的代码 javap -c MyTest0 为了方便编辑 在window环境下使用 以下指令 可以将编译后的代码之间输出到MyTest0.txt javap -c MyTest0 > MyTest0.txt 然后用编辑器打开 MyTest0.txt 长这个样子的 好像还是看不懂hh，这个时候告诉自己不要慌，这些东西需要结合Jvm指令集与上面的那张图2 结合起来解析 PS （ /--/ 开头的注释是我自己加的说明） Compiled from \"MyTest0.java\" public class com.dms.MyTest0 { public com.dms.MyTest0(); Code: 0: aload_0 /--/ 调用超类构造方法，实例初始化方法，私有方法 (看这里就能明白为什么，为什么类里面没有构造方法却能new对对象，编译器会自动调用超类构造方法) 1: invokespecial #1 // Method java/lang/Object.\"\":()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #2 // Method sum:()V /--/ 调用静态方法 sum() 3: return static void sum(); Code: 0: iconst_5 /--/ 将int型5推送至sum方法栈顶 1: istore_0 /--/ 将栈顶int型数值存入第一个本地变量(也就是存到sum局部变量表) 2: iconst_3 /--/ 将int型3推送至sum方法栈顶 3: istore_1 /--/ 将栈顶int型数值存入第二个本地变量(也就是存到sum局部变量表) /--/ 获取指定类的静态域，并将其值压入栈顶 4: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 7: iload_0 /--/ 将第一个int型本地变量推送至栈顶(也就是把局部变量里的5 推至栈顶) 8: iload_1 /--/ 将第二个int型本地变量推送至栈顶(也就是把局部变量里的3 推至栈顶) 9: iadd /--/ 将栈顶两int型数值相加并将结果压入栈顶 也就是8 10: invokevirtual #4 // Method java/io/PrintStream.println:(I)V /--/ 调用实例方法 也就是调用打印方法把8打印出来 13: return /--/ 返回 } 基础流程就是图2与以上 /--/ 注释所写的那样子了 自己跟着流程操作一遍可能会更好理解一些，更多的JVM指令集可以参考以下链接，或自行网上搜索 https://www.cnblogs.com/dreamroute/p/5089513.html 图二说过当新new出来的对象很大时该对象会直接进入老年代,直接跑段代码看看是不是真的是这样子的。 public class MyTest { /** * 每个对象有一个1M的属性 使它一创建出来就是一个大对象 */ byte[] bytes = new byte[1024 * 1000]; public static void main(String[] args) throws InterruptedException { // 程序刚启动时JVM会有一些初始化的处理,为避免影响实验结果，先睡眠5秒 Thread.sleep(5000); // 为避免垃圾回收机制自动回收没有引用的对象,这里用一个数组先装着，保证对象存活 List list = new ArrayList<>(); // 循环添加1000个大对象 for (int i = 0; i 以上代码的执行结果，心里预期应该是老年代的空间在1000个对象添加完成前一直会保持增长，在添加完一千个对象之后执行垃圾回收，空间又会断崖式的下跌。口说无凭，我们使用个工具观察一下老年代的内存情况。这里使用的工具是JDK带的jconsole window环境下使用小黑窗输入jconsole 即可调出来 选择本地进程 选择自己的程序 然后选择内存 内存池\"PS Old Gen\" 观察老年代的内存变化 可以看到内存曲线变化是符合心理预期的 xiaozhaorong all right reserved，powered by Gitbook该文章修订时间： 2021-06-28 16:36:29 "}}